// This file is AUTOGENERATED, do not edit.
#pragma once
#include "utils/protomessage.h"
namespace pblczero {
class EngineVersion : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  EngineVersion(EngineVersion&&) = default;
  static EngineVersion CreateNotOwned(std::string_view s) {
    return EngineVersion(s);
  }
  bool has_major() const { return WireFieldCount(8) > 0; }
  std::int32_t major() const {
    return lczero::kind_of_bit_cast<std::int32_t>(GetVarintVal(8, 0));
  }
  bool has_minor() const { return WireFieldCount(16) > 0; }
  std::uint32_t minor() const {
    return lczero::kind_of_bit_cast<std::uint32_t>(GetVarintVal(16, 0));
  }
  bool has_patch() const { return WireFieldCount(24) > 0; }
  std::uint32_t patch() const {
    return lczero::kind_of_bit_cast<std::uint32_t>(GetVarintVal(24, 0));
  }
};
class Weights : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  Weights(Weights&&) = default;
  static Weights CreateNotOwned(std::string_view s) { return Weights(s); }
  class Layer : public lczero::ProtoMessage {
   public:
    using ProtoMessage::ProtoMessage;
    Layer(Layer&&) = default;
    static Layer CreateNotOwned(std::string_view s) { return Layer(s); }
    bool has_min_val() const { return WireFieldCount(13) > 0; }
    float min_val() const { return GetFloatVal(13, 0); }
    bool has_max_val() const { return WireFieldCount(21) > 0; }
    float max_val() const { return GetFloatVal(21, 0); }
    bool has_params() const { return WireFieldCount(26) > 0; }
    std::string_view params() const { return GetBytesVal(26, 0); }
  };
  class ConvBlock : public lczero::ProtoMessage {
   public:
    using ProtoMessage::ProtoMessage;
    ConvBlock(ConvBlock&&) = default;
    static ConvBlock CreateNotOwned(std::string_view s) { return ConvBlock(s); }
    bool has_weights() const { return WireFieldCount(10) > 0; }
    Layer weights() const { return Layer::CreateNotOwned(GetBytesVal(10, 0)); }
    bool has_biases() const { return WireFieldCount(18) > 0; }
    Layer biases() const { return Layer::CreateNotOwned(GetBytesVal(18, 0)); }
    bool has_bn_means() const { return WireFieldCount(26) > 0; }
    Layer bn_means() const { return Layer::CreateNotOwned(GetBytesVal(26, 0)); }
    bool has_bn_stddivs() const { return WireFieldCount(34) > 0; }
    Layer bn_stddivs() const {
      return Layer::CreateNotOwned(GetBytesVal(34, 0));
    }
    bool has_bn_gammas() const { return WireFieldCount(42) > 0; }
    Layer bn_gammas() const {
      return Layer::CreateNotOwned(GetBytesVal(42, 0));
    }
    bool has_bn_betas() const { return WireFieldCount(50) > 0; }
    Layer bn_betas() const { return Layer::CreateNotOwned(GetBytesVal(50, 0)); }
  };
  class SEunit : public lczero::ProtoMessage {
   public:
    using ProtoMessage::ProtoMessage;
    SEunit(SEunit&&) = default;
    static SEunit CreateNotOwned(std::string_view s) { return SEunit(s); }
    bool has_w1() const { return WireFieldCount(10) > 0; }
    Layer w1() const { return Layer::CreateNotOwned(GetBytesVal(10, 0)); }
    bool has_b1() const { return WireFieldCount(18) > 0; }
    Layer b1() const { return Layer::CreateNotOwned(GetBytesVal(18, 0)); }
    bool has_w2() const { return WireFieldCount(26) > 0; }
    Layer w2() const { return Layer::CreateNotOwned(GetBytesVal(26, 0)); }
    bool has_b2() const { return WireFieldCount(34) > 0; }
    Layer b2() const { return Layer::CreateNotOwned(GetBytesVal(34, 0)); }
  };
  class Residual : public lczero::ProtoMessage {
   public:
    using ProtoMessage::ProtoMessage;
    Residual(Residual&&) = default;
    static Residual CreateNotOwned(std::string_view s) { return Residual(s); }
    bool has_conv1() const { return WireFieldCount(10) > 0; }
    ConvBlock conv1() const {
      return ConvBlock::CreateNotOwned(GetBytesVal(10, 0));
    }
    bool has_conv2() const { return WireFieldCount(18) > 0; }
    ConvBlock conv2() const {
      return ConvBlock::CreateNotOwned(GetBytesVal(18, 0));
    }
    bool has_se() const { return WireFieldCount(26) > 0; }
    SEunit se() const { return SEunit::CreateNotOwned(GetBytesVal(26, 0)); }
  };
  bool has_input() const { return WireFieldCount(10) > 0; }
  ConvBlock input() const {
    return ConvBlock::CreateNotOwned(GetBytesVal(10, 0));
  }
  size_t residual_size() const { return WireFieldCount(18); }
  Residual residual(size_t i) const {
    return Residual::CreateNotOwned(GetBytesVal(18, i));
  }
  lczero::ProtoIterator<Residual> residual() const {
    return lczero::ProtoIterator<Residual>(residual_size(), [this](size_t i) {
      return Residual::CreateNotOwned(GetBytesVal(18, i));
    });
  }
  bool has_policy1() const { return WireFieldCount(90) > 0; }
  ConvBlock policy1() const {
    return ConvBlock::CreateNotOwned(GetBytesVal(90, 0));
  }
  bool has_policy() const { return WireFieldCount(26) > 0; }
  ConvBlock policy() const {
    return ConvBlock::CreateNotOwned(GetBytesVal(26, 0));
  }
  bool has_ip_pol_w() const { return WireFieldCount(34) > 0; }
  Layer ip_pol_w() const { return Layer::CreateNotOwned(GetBytesVal(34, 0)); }
  bool has_ip_pol_b() const { return WireFieldCount(42) > 0; }
  Layer ip_pol_b() const { return Layer::CreateNotOwned(GetBytesVal(42, 0)); }
  bool has_value() const { return WireFieldCount(50) > 0; }
  ConvBlock value() const {
    return ConvBlock::CreateNotOwned(GetBytesVal(50, 0));
  }
  bool has_ip1_val_w() const { return WireFieldCount(58) > 0; }
  Layer ip1_val_w() const { return Layer::CreateNotOwned(GetBytesVal(58, 0)); }
  bool has_ip1_val_b() const { return WireFieldCount(66) > 0; }
  Layer ip1_val_b() const { return Layer::CreateNotOwned(GetBytesVal(66, 0)); }
  bool has_ip2_val_w() const { return WireFieldCount(74) > 0; }
  Layer ip2_val_w() const { return Layer::CreateNotOwned(GetBytesVal(74, 0)); }
  bool has_ip2_val_b() const { return WireFieldCount(82) > 0; }
  Layer ip2_val_b() const { return Layer::CreateNotOwned(GetBytesVal(82, 0)); }
};
class TrainingParams : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  TrainingParams(TrainingParams&&) = default;
  static TrainingParams CreateNotOwned(std::string_view s) {
    return TrainingParams(s);
  }
  bool has_training_steps() const { return WireFieldCount(8) > 0; }
  std::uint32_t training_steps() const {
    return lczero::kind_of_bit_cast<std::uint32_t>(GetVarintVal(8, 0));
  }
  bool has_learning_rate() const { return WireFieldCount(21) > 0; }
  float learning_rate() const { return GetFloatVal(21, 0); }
  bool has_mse_loss() const { return WireFieldCount(29) > 0; }
  float mse_loss() const { return GetFloatVal(29, 0); }
  bool has_policy_loss() const { return WireFieldCount(37) > 0; }
  float policy_loss() const { return GetFloatVal(37, 0); }
  bool has_accuracy() const { return WireFieldCount(45) > 0; }
  float accuracy() const { return GetFloatVal(45, 0); }
  bool has_lc0_params() const { return WireFieldCount(50) > 0; }
  std::string_view lc0_params() const { return GetBytesVal(50, 0); }
};
class NetworkFormat : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  NetworkFormat(NetworkFormat&&) = default;
  static NetworkFormat CreateNotOwned(std::string_view s) {
    return NetworkFormat(s);
  }
  enum InputFormat {
    INPUT_UNKNOWN = 0,
    INPUT_CLASSICAL_112_PLANE = 1,
    INPUT_112_WITH_CASTLING_PLANE = 2,
  };
  bool has_input() const { return WireFieldCount(8) > 0; }
  InputFormat input() const {
    return lczero::kind_of_bit_cast<InputFormat>(GetVarintVal(8, 0));
  }
  enum OutputFormat {
    OUTPUT_UNKNOWN = 0,
    OUTPUT_CLASSICAL = 1,
    OUTPUT_WDL = 2,
  };
  bool has_output() const { return WireFieldCount(16) > 0; }
  OutputFormat output() const {
    return lczero::kind_of_bit_cast<OutputFormat>(GetVarintVal(16, 0));
  }
  enum NetworkStructure {
    NETWORK_UNKNOWN = 0,
    NETWORK_CLASSICAL = 1,
    NETWORK_SE = 2,
    NETWORK_CLASSICAL_WITH_HEADFORMAT = 3,
    NETWORK_SE_WITH_HEADFORMAT = 4,
  };
  bool has_network() const { return WireFieldCount(24) > 0; }
  NetworkStructure network() const {
    return lczero::kind_of_bit_cast<NetworkStructure>(GetVarintVal(24, 0));
  }
  enum PolicyFormat {
    POLICY_UNKNOWN = 0,
    POLICY_CLASSICAL = 1,
    POLICY_CONVOLUTION = 2,
  };
  bool has_policy() const { return WireFieldCount(32) > 0; }
  PolicyFormat policy() const {
    return lczero::kind_of_bit_cast<PolicyFormat>(GetVarintVal(32, 0));
  }
  enum ValueFormat {
    VALUE_UNKNOWN = 0,
    VALUE_CLASSICAL = 1,
    VALUE_WDL = 2,
  };
  bool has_value() const { return WireFieldCount(40) > 0; }
  ValueFormat value() const {
    return lczero::kind_of_bit_cast<ValueFormat>(GetVarintVal(40, 0));
  }
};
class Format : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  Format(Format&&) = default;
  static Format CreateNotOwned(std::string_view s) { return Format(s); }
  enum Encoding {
    UNKNOWN = 0,
    LINEAR16 = 1,
  };
  bool has_weights_encoding() const { return WireFieldCount(8) > 0; }
  Encoding weights_encoding() const {
    return lczero::kind_of_bit_cast<Encoding>(GetVarintVal(8, 0));
  }
  bool has_network_format() const { return WireFieldCount(18) > 0; }
  NetworkFormat network_format() const {
    return NetworkFormat::CreateNotOwned(GetBytesVal(18, 0));
  }
};
class Net : public lczero::ProtoMessage {
 public:
  using ProtoMessage::ProtoMessage;
  Net(Net&&) = default;
  static Net CreateNotOwned(std::string_view s) { return Net(s); }
  bool has_magic() const { return WireFieldCount(13) > 0; }
  std::uint32_t magic() const {
    return lczero::kind_of_bit_cast<std::uint32_t>(GetFixed32Val(13, 0));
  }
  bool has_license() const { return WireFieldCount(18) > 0; }
  std::string_view license() const { return GetBytesVal(18, 0); }
  bool has_min_version() const { return WireFieldCount(26) > 0; }
  EngineVersion min_version() const {
    return EngineVersion::CreateNotOwned(GetBytesVal(26, 0));
  }
  bool has_format() const { return WireFieldCount(34) > 0; }
  Format format() const { return Format::CreateNotOwned(GetBytesVal(34, 0)); }
  bool has_training_params() const { return WireFieldCount(42) > 0; }
  TrainingParams training_params() const {
    return TrainingParams::CreateNotOwned(GetBytesVal(42, 0));
  }
  bool has_weights() const { return WireFieldCount(82) > 0; }
  Weights weights() const {
    return Weights::CreateNotOwned(GetBytesVal(82, 0));
  }
};
}  // namespace pblczero
